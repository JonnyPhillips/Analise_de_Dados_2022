---
title: "Mapas e Analises Espaciais"
output:
  distill::distill_article:
    toc: true
    toc_float: true
    toc_depth: 1
---

<style>
div.green { background-color:#e5f5e0; border-radius: 5px; padding: 20px;}
</style>

<style>
div.orange { background-color:#fee6ce; border-radius: 5px; padding: 20px;}
</style>

<style>
div.blue { background-color:#deebf7; border-radius: 5px; padding: 20px;}
</style>

<style>
div.purple { background-color:#9e9ac8; border-radius: 5px; padding: 20px;}
</style>


```{r setup, include=FALSE, echo=F}
knitr::opts_chunk$set(echo = T, eval=T, highlight=T)
library("nycflights13")
library("tidyverse")
library("rmarkdown")
library("knitr")
library("kableExtra")
```

# Dados Espaciais

Dados espaciais são dados organizados por localização e permitem novos tipos de análise e visualização. Explorar mapas em R nos permite praticar e estender muitas das ferramentas que aprendemos nas últimas semanas - manipulação de dados, joins e gráficos.

O que diferencia dados espaciais de outros tipos de dados? Dados espaciais contém variáveis que identificam a localização de cada ponto no mundo, como o latitude e longitude: 13$^\circ$26'22"N, 17$^\circ$8'21"E. Estes valores nos permitem localizar um ponto no mundo, comparar com outros pontos, e visualizar os pontos num mapa de duas dimensões. 

Lembre-se do nosso tibble de `airports` do tutorial passado? Ele contém a localização dos aeroportos nos Estados Unidos nas colunas 'lat' e 'lon'. Como podemos analisar estes dados espaciais? 

```{r, eval=F}
airports
```

```{r, echo=F}
airports %>% paged_table()
```

Para analisar estes dados como dados espaciais precisamos dizer a R quais são as variáveis de localização. Isto exige uma nova biblioteca: `sf`, o acrônimo para 'simple features'.

```{r}
#install.packages("sf")
library(sf)
```

O `sf` traz mais poder para os nossos tibbles, permitindo eles entender dados espaciais. Para facilitar, todas as nossas operações com dados espaciais começam com `st_` (e não `sf`...absurdamente). Só temos que indicar para R quais variáveis do tibble original identificam o longitude e latitude das observações, usando a função `st_as_sf()`. O argumento `coords=` aceita um vetor com os nomes das duas colunas, o longitude e latitude (neste ordem).

```{r}
airports_test <- airports %>% st_as_sf(coords=c("lon","lat"))
```

Como fica o nosso tibble `airports_test` agora? Abre o tibble para ver. Parece quase ígual...e isso é importante - dados espaciais não são muito diferentes de outros dados; eles ainda ficam num tibble. Cada observação tem várias colunas de dados não-espaciais ('faa', 'name' etc.). Mas agora há uma nova coluna também, `geometry`. Ela codifica os dados de longitude e latitude num formato mais complexo que facilita operações e visualizações espaciais. Veja que o valor de cada observação da `geometry` é "<S3: sfc_POINT>". Além de mostrar que o tipo de dado espacial é um ponto (vamos ver alternativas em breve), isto não significa muito, os valores de longitude e latitude são escondidos para simplificar o nosso tibble. 

```{r}
airports_test
```

Verifique o tipo do objeto `airports_test`:

```{r}
class(airports_test)
```

Temos vários resultados aqui - é um objeto 'simple features', mas também um _tbl_ (tibble) e _data.frame_! Isso significa que podemos aplicar todas as funções do _dplyr_ com dados espaciais também. 

O que podemos fazer com o nosso tibble de `airports_test` extra-poderoso e espacialmente-habilitada? Muitas coisas, e vamos ver as possibilidades abaixo, mas por enquanto vamos visualizar os nossos dados num mapa simples. O nosso gramática de gráficos ggplot facilita a visualização de dados espaciais no formato bem conhecido, com uma geometria específica: `geom_sf()`, e graças a muito trabalho de pessoas desconhecidas, não precisamos especificar nenhum argumento:

```{r}
airports_test %>% ggplot() +
  geom_sf()
```

É isso mesmo. Já criou a sua primeira mapa, parabéns! O que está acontecondo no seu gráfico, pode interpretar? Veja que o eixo x mostra os valores de longitude, e o eixo y os valores de latitude. Aperece um ponto (a geometria, e o conteúdo da coluna `geometry` em cada lugar apropriado). 

A beleza de trabalhar com dados espaciais em nosso formato padrão de um tibble é que podemos aplicar todas as nossas ferramentas normais para transformar e preparar os dados. Por exemplo, vamos limitar o escopo dos dados para os fusos horários dos Estados Unidos continental (e tirando alguns aeroportos específicos mal-codificados). 

```{r}
airports_test <- airports_test %>% filter(tz<0 & !faa %in% c("EEN", "SYA")) 

airports_test %>% 
  ggplot() +
  geom_sf()
```

Faz mais sentido agora, sim?

# Sistemas de Coordenados

Mesmo que seja reconhecível, o mapa acima parece um pouco distorcido, né? Não é. É uma viés humana esperar um tipo de mapa específica que já conhecemos de experiência, mas *não existe uma representação única e correta de dados espaciais na sua tela*. 

Por que? Porque o mundo não é plano. E representar locais que existem numa esfera (na verdade, uma esferóide oblato) em papel ou na sua tela em duas dimensões não tem uma solução única. Existem milhares de possibilidades para como transformar um local em três dimensões para duas, e sempre gera alguma tipa de distorção. Algumas das transformações têm nomes conhecidos, como 'Mercator' ou 'Robinson', cada um representando um 'sistema de coordenados' (CRS, Coordinate Reference System). 

O CRS pode aparecer complicado, mas não se preocupe, não precisamos entender as detalhes. Só temos que verificar três coisas:

**1. Que nós entendemos o CRS dos nossos dados brutos.** Mesmo que a padrão é salvar dados espaciais com longitude e latitude, às vezes eles venham em outro formato, e também há outros detalhes para especificar para interpretar o longiture e latitude, como quanto 'esmagada' é o mundo de uma esfera perfeito. 

Então deveríamos ter gerado o banco espacial de `airports` especificando o CRS dos dados no arquivo, com o argumento de `CRS`:

```{r}
airports <- airports %>% st_as_sf(coords=c("lon","lat"), 
                                  crs=4326) %>% 
  filter(tz<0 & !faa %in% c("EEN", "SYA")) 
```

Por que '4326'? Idealmente, devemos confirmar com o fornecedor dos dados o CRS em que eles foram salvos. Aqui, como o longitude e latitude parece que eles estão em graus (entre -180 e 180) é provável que devemos usar o sistema "WGS84" (um sistema de coordenadas geográficas (não projetadas)). Um atalho para especificar o WGS84 é usar o numero _4326_ no argumento 'crs'. Para outros atalhos para sistemas de coordenados que pode usar com dados salvados em outros sistemas de coordenados, pode aproveitar do site [http://epsg.io/](http://epsg.io/).

Abre o `airports` e vai aparecer uma linha de `CRS` agora:

```{r}
airports
```

**2. Que nós escolhamos o CRS em que queremos visualizar os nossos dados.** Quando chamamos `geom_sf`, ele usa o CRS definido em nosso tibble. Mas em qualquer momento podemos transformar o CRS atual para uma alternativa, por exemplo um CRS que melhor representa um lugar específico no mundo. Usamos `st_transform()` em nosso pipe de trabalho para alterar o CRS, especificando o novo número da projeção desejada. 

Por exemplo, a projeção Mercator tem número 3857:

```{r}
airports %>% st_transform(3857) %>%
  ggplot() +
  geom_sf()
```

Uma projeçõ focada nos Estados Unidos, 3751:

```{r}
airports %>% st_transform(3751) %>%
  ggplot() +
  geom_sf()
```

Mais uma, a projeção Winkel, 54018:

```{r}
airports %>% st_transform(54018) %>%
  ggplot() +
  geom_sf()
```

**3. Que todas as camadas da nossa análise/visualização usam a mesma projeção.** Na mesma forma que não podemos comparar kilometros e milhas direitamente, seria errado comparar dados em CRS diferentes. O mesmo local vai aparece em posições diferentes. Temos que usar `st_transform()` para padronizar as camadas. 

## Calculando Distâncias

O CRS (a projeção) é especialmente relevante quando precisamos calcular distâncias de observações espaciais. O CRS 4326 é geográfico (sem projeção) então a unidade de distância fica em graus, minutos e segundos, que não faz nenhum sentido para ninguém. Para cálculos em metros, temos que usar um CRS projetado (por exemplo, os outros mostrados acima). Então antes de calcular distância, use `st_transform()` para definir um CRS projetado. 

Há muitas possibilidades para calular distâncias, mas vamos usar uma função simples para calcular a distância entre todos os aeroportos, `st_distance()`. Ela não precisa nenhum argumento, mas vamos pegar uma amostra aleatória de 10 aeroportos primeiramente para não sobrecarregar os nossos computadores e deixar o resultado mais simples interpretar:

```{r, eval=F}
airports %>% sample_n(10) %>% st_distance()
```

```{r}
set.seed(3)
airports %>% sample_n(10) %>% 
  st_distance() 
```

O resultado é um 'matriz' (um tibble com apenas números), com a unidade da mensuração especificada no início ('Units: [m]'). Como lemos o resultado? Entre aeroporto um e dois há uma distância de 555.409,9 metros, 555km. (Se quiser, pode transformer o resultado em um tibble com `...%>% as_tibble()`).

# Trabalhando com Polígonos

Áreas administrativas são geralmente representadas como polígonos em mapas. Em geral, obtemos esses polígonos como 'shapefiles' produzidos por uma agência oficial. Podemos abrir qualquer tipo de shapefile (pontos, linhas ou polígonos) com a função _st_read_. Vamos abrir um shapefile (simplificado) dos estados dos Estados Unidos, do link [aqui](states_21basic/states.shp).
**FIX LINK**

```{r, eval=F, warning=F, message=F}
states <- st_read("states.shp")
```

```{r, echo=F, warning=F, message=F}
states <- st_read("states_21basic/states.shp")
```

Abre o nosso objeto `states` para ver o conteúdo:

```{r}
states
```

É um tibble do tipo 'sf' também! Observe que o 'geometry type' agora é 'MULTIPOLYGON', e que ele tem um CRS de 4269, diferente dos nossos pontos de aeropotos.  Temos 51 áreas, um para cada estado (mais o DF), e uma coluna de 'geometria'. 

Como podemos visualizar este mapa? Exatamente o mesmo que antes (pode demorar para abrir):

```{r}
states %>% ggplot() +
  geom_sf()
```

E se quisemos visualizar ambos os polígonos e os pontos dos aeroportos? É essencial padronizar os CRS para que estamos trabalhando com a mesma projeção para todos as camadas, então vamos transformar a projeção de `states` para o CRS 4326, o mesmo de `airports`. 

Para adicionar a camada de aeroportos, é só especificar mais uma camada de `geom_sf()` com o argumento opcional de `data=airports` no início. (Isto é uma estratégia geral para adicionar camadas de mais de um banco de dados num gráfico). 

```{r}
states %>% st_transform(4326) %>%
  ggplot() +
  geom_sf() +
  geom_sf(data=airports)
```

Perfeito! Todos os pontos cabem dentro das bordas do país. 

# Aperfecionando a Visualização dos mapas

Alterando a apresentação dos nossos mapas depende nas mesmas habilidades com todos os outros gráficos de ggplot. Vamos adicionar um título, alterar o tamanho dos pontos, e o cor das bordas:

```{r}
states %>% st_transform(4326) %>%
  ggplot() +
  geom_sf(colour="#756bb1") +
  geom_sf(data=airports, size=0.5) +
  ggtitle("Mapa de Aeroportos e Estados nos EUA")
```

Podemos também alterar o cor da área dos estados dependendo do seu `SUB_REGION`, com uma escala apropriada, e o cor dos aeroportos dependendo do seu altitude, com uma escala apropriada. 

```{r}
states %>% st_transform(4326) %>%
  ggplot() +
  geom_sf(aes(fill=SUB_REGION), colour="#756bb1", alpha=0.2) +
  scale_fill_brewer(palette="Set2") +
  geom_sf(data=airports, aes(colour=alt), size=0.5) +
  scale_colour_gradient(low="#00441b", high="#ef3b2c") +
  ggtitle("Mapa de Aeroportos e Estados nos EUA")
```

Com mapas, é frequentemente útil tirar o fundo, as linhas, e os eixos com `theme_void()`:

```{r}
states %>% st_transform(4326) %>%
  ggplot() +
  geom_sf(aes(fill=SUB_REGION), colour="#756bb1", alpha=0.2) +
  scale_fill_brewer(palette="Set2") +
  geom_sf(data=airports, aes(colour=alt), size=0.5) +
  scale_colour_gradient(low="#00441b", high="#ef3b2c") +
  ggtitle("Mapa de Aeroportos e Estados nos EUA") +
  theme_void()
```

# Georeferenciamento

Até agora, os nossos dados espaciais já chegaram quase pronto para usar. O que podemos fazer se não tivermos dados espaciais? Temos que criar eles. Pode usar um aplicativo para capturar dados com GPS, ou pode 'georeferenciar' descrições de lugares, como endereços. 

Por exemplo, vamos criar um tibble simples com alguns endereços, e usar a função `geocode_OSM` do pacote `tmaptools` para converter o endereço em coordenados de longitude e latitude. A função usa o banco de dados de Open Street Maps. 

```{r}
library(tmaptools)

Lugares <- tibble(ID=c(1,2),
       Endereço=c("Av. Prof. Luciano Gualberto, 298-460 - Butantã, São Paulo, Brazil",
                 "Av. Paulista, 1578 - Bela Vista, São Paulo, Brazil"))

Lugares <- geocode_OSM(Lugares$Endereço, projection=4326, as.sf=T)
```

Note que especificamos o CRS (o `projection`) em que queremos receber os dados, para que ele seja padronizado com as nossas outras camadas. E usamos `as.sf` para que o resultado já é um tibble de simple features pronto para analisar/visualizar.

## Mapas Interativas

Como podemos verificar o local dos nossos endereços? É mais fácil com o contexto geográfico, como em google maps, e com um mapa interativo. Geralmente, em relatórios, mapas estáticos são mais apropriados, mas às vezes é útil explorar os nossos dados espaciais interativamente, ou em documentos de HTML. Para isso, usamos a função `mapview()` no pacote do mesmo nome. É fácil:

```{r}
library(mapview)

Lugares %>% mapview()
```

# Joins Não Espaciais

Observe que os nossos dados espaciais venham com uma tabela, e normalmente com um identificador único para cada observação (unidade espacial). Isto abre uma oportunidade - se temos dados não-espaciais que queremos mapear, é fácil tornar eles espacial - é só juntar o banco não-espacial com o banco espacial usando o identificador comum, exatamente como discutimos no tutorial anterior. Na prática é muito mais comum pegar um shapefile genêrico de polígonos/pontos, e cruzar com um banco de dados não-espacial.

Por exemplo, queremos mapear o número de voos de Nova Iorque que chegam em cada aeroporto de destino em 2013. Com apenas o banco de dados `flights` isso seria impossível. Mas em combinação com o nosso banco de `airports` espacial, é rápdo. Primeiro, qual é a unidade espacial de análise que desejamos? É cada aeroporto de destino, então temos que agregar/resumir o banco de dados de `flights` para cada destino. Por enquanto, pode ser apenas o número de voos:

```{r}
flights_por_dest <- flights %>% group_by(dest) %>% 
  tally()
```


Segundo, vamos isolar o identificador comum, neste caso o código de aeroporto destino, `dest` em um banco, `faa` no outro, e rodar o `left_join()` como normal. Uma dica - lembre que `left_join()` preserva a estrutura e atributos do objeto na esquerda? Dado que queremos o resultado do nosso join manter o seu status espacial (de 'sf'), é sempre uma boa ideia colocar o objeto espacial na esquerda de `left_join()`. 

```{r}
airports_flights <- airports %>% rename(dest=faa) %>%
  left_join(flights_por_dest, by="dest")
```

Agora, a coluna 'n' é disponível no tibble `airports_flights` para visualizar:

```{r}
airports_flights %>% ggplot() +
  geom_sf(aes(colour=n))
```

Só temos poucos dos aeroportos no banco de dados `flights`, então pode ser melhor usar um `inner_join()` para tirar os aeroportos ausentes:

```{r}
airports %>% rename(dest=faa) %>%
  inner_join(flights_por_dest, by="dest") %>% 
  ggplot() +
  geom_sf(aes(colour=n))
```


# Joins Espaciais

O mundo espacial abre um novo tipo de join entre diversas bancos de dados - joins espaciais que são definidos pela localização semelhante e não por uma chave comum nas tabelas de dados. Existe diversas tipos de joins espaciais mas vamos focar sobre um join entre uma camada de polígonos e uma camada de pontos. 

Especificamente, queremos saber quantos aeroportos (pontos) existem em cada estado (polígono). A função para um join espacial é _st\_join_. Como sempre, a regra crucial é que as duas camadas espaciais têm que ter o mesmo CRS, então vamos usar `st_transform` para padronizar as duas para 4326. 

```{r}
airports_states <- airports  %>% 
  st_join(states %>% st_transform(4326))
```

Agora, o objeto `airports_states` contém todos as aeroportos, com colunas adicionais para os detalhes do estado em que o aeroporto fica (geograficamente). Não tivemos estes dados anteriormente então vamos visualizar os aeroportos por 'SUB_REGION', como exemplo:

```{r}
airports_states %>% ggplot() + 
  geom_sf(aes(colour=SUB_REGION))
```

Qual tipo de unidade espacial é cada observação em `airports_states`? É um ponto, um aeroporto. Por que não um polígono, como os estados que usamos no `st_join`? Porque o `st_join` também faça por padrão um join a esquerda, como `left_join`, então ele preserve os atributos do objeto na esquerda, neste caso os pontos dos aeroportos. 

Se quisemos juntar os dados por estado e manter a geometria dos polígonos dos estados, apenas temos que invertir o ordem dos objetos no `st_join`: 

```{r}
states_airports <- states %>% st_transform(4326) %>% 
  st_join(airports)
```

Agora, o objeto 'states_airports' contém os dados de cada estado e colunas adicionais com dados dos aeroportos que ficam (geograficamente) no estado. Obviamente há vários aeroportos por estado, então cada estado é *duplicado* em diversas observaçoes. Inspecte as colunas da direita de `states_airports` para ver que cada observação é um aeroporto diferente. 

Mas o mesmo polígono do estado duplicado muitas vezes para cada aeroporto não ajuda nada - temos que agregar os nossos dados por estado para deixar um polígono por estado. Por exemplo, para calcular o número de aeroportos por estado, e visualizar o resultado:

```{r}
states_num_airports <- states_airports %>% group_by(STATE_NAME) %>% 
  tally() 

states_num_airports %>%
  ggplot() +
  geom_sf(aes(fill=n))
```

Os joins espaciais ampliam a nossa criatividade, abrindo comparações novas. Há muitas possibilidades, mas os básicos são sempre os mesmos que descrevemos aqui.

# Rasters

Existe um outro formato para dados espaciais que não é baseado em formas geométricas (polígonos, pontos e linhas), mas em uma grade regular com valores específicos em cada célula x, y - isto é um 'raster' e para trabalhar com ele usamos o pacote 'raster'. Vamos usar o código debaixo para abrir um arquivo raster de densidade populacional no Camboja, que é simplesmente uma imagem com extensão _.tif_.

```{r}
library(raster)
download.file("https://github.com/JonnyPhillips/Curso_R/raw/master/khm_popdenr_landscan_2011.zip",destfile="khm_popdenr_landscan_2011.zip")
unzip("khm_popdenr_landscan_2011.zip")
cambodia <- raster("khm_popdenr_landscan_2011.tif")
```

Para visualizar o nosso raster, precisamos transformar ele em um data.frame simples (não um tibble) e usar o ggplot com a geometria de _geom_tile_. Não se preocupe com os detalhes, mas experimente com o código abaixo:

```{r}
cambodia %>% as("SpatialPixelsDataFrame") %>% 
  as.data.frame() %>% 
  ggplot() + 
  geom_tile(aes(x=x,y=y,fill=khm_popdenr_landscan_2011))
```

Este mapa parece bem chato porque os dados são altamente 'skewed', com grandes outliers apenas na capital. Frequentemente com rasters é útil transformá-los em uma escala de log para visualizar, com a opção de `trans="log"` em nossa camada de escala. Vamos também limpar o fundo e adicionar uma escala de cores.

```{r}
cambodia %>% as("SpatialPixelsDataFrame") %>% 
  as.data.frame() %>% 
  ggplot() + 
  geom_tile(aes(x=x,y=y,fill=khm_popdenr_landscan_2011)) +
  coord_equal() +
  theme_void() +
  scale_fill_gradient(low="white",high="red",na.value="white", trans="log")
```

Também podemos criar mapas de raster interativos com mapview. (Adicionamos uma pequena quantidade ao log para evitar valores infinitos e erros).

```{r}
log(cambodia+0.00001) %>% 
  brick() %>% 
  mapview(layer.name="khm_popdenr_landscan_2011")
```

